---
status: draft
flip: [xxx]
authors: Tarak Ben Youssef (tarak.benyoussef@dapperlabs.com)
sponsor: 
updated: 2023-07-27
---

# FLIP [xxx]: commit reveal scheme for non-reverted randomness

## Objective

Although Cadence exposes a secure randomness generated by the Flow protocol,
transactions are able to reject their results after the random is revealed.
The purpose of the FLIP is to provide a safe pattern to use randomness in transactions
so that it's not possible to revert non-favorable randomized transaction results.

## Motivation

The Flow Virtual Machine (FVM) underwent [changes](https://github.com/onflow/flow-go/pull/4498) that made the Cadence randomness function `unsafeRandom` (a new name is being discussed in [another FLIP](https://github.com/onflow/flips/pull/120)) backed by an unbiasable, unpredictable and verifiable distributed randomness. The distributed randomness is generated within the Flow protocol for every block and we refer to it by source of randomness [SoR], as in the original [Flow paper](https://arxiv.org/pdf/2002.07403.pdf)

The Cadence function can be used safely in some applications where the transaction results are NOT deliberately reverted after the random number is revealed (a contract distributing random NFTs to registered users or on-chian lucky draw). 

However, many applications require a non-trusted party (for instance app users) to submit a transaction calling a randomized (non-deterministic) contract. A user can write the transaction in a way that it inspects the app contract results and cancel the changes if they are not favorable.
As an example, consider a simple coin toss randomized contract where users can bet an amount of tokens against a random binary output. If the coin toss contract outputs `1`, the user doubles their bet. If the coin toss contract outputs `0`, the user loses their bet in favour of the coin toss. Although the user (or the honest coin toss contract) cannot predict or bias the outcome, the user transaction can check the randomized result and cancel the transaction if they are losing their bets. This can be done by calling an exception causing the transaction to error. All temporary state changes are cancelled and the user can repeat the process till they double their bet.

Note that this is an inherent behavior of atomic contract platforms where the programming language is able to error and all temporary results of the transaction are not applied to to the state. While this is not a limitation of the programming language or the safe distributed randomness, a contract platform should provide developers with tools to implement a non-revertible usage of randomness. 

## User Benefit

Adding a safe pattern to reveal randomness without the transaction results being reverted unlocks application relying on randomness (for instance the coin toss contract described above). Not providing such pattern pushes developers to rely on risky solutions with possible security flaws.

## Design Proposal

The proposed design is a commit-reveal pattern. 

The solution requires infrastructure changes to provide new data to the transaction execution environment:

 1. a new FVM function that exposes the current block's SoR (more precisely a derived value from the protocol `SoR_A`) to Cadence runtime. Note that `unsafeRandom` only exposes randoms derived from `SoR_A` through a pseudo-random generator (PRG) but not the `SoR_A` itself. 
 2. a new system core-contract that stores a limited history of SoRs for the past `N` blocks. The new FVM function in (1) is only available to the history contract, and is not available to other non-system transactions. Note that system-transactions in Flow are executed at the end of each block, after all non-system transactions of the block are executed. The proposal suggests to add a new system transaction that adds the current block's `SoR_A` to the SoR history contract (it also removes the oldest block's `SoR_A`). The contract indexes the SoR history by block height. 
 3. an on-chain implementation of a PRG is required. A PRG is initialized with an SoR and can generate a sequence of random numbers for an application. It's up to the application to use a suitable PRG instance. At least one recommended PRG implementation should be provided as part of the FLIP implementation (precise instance to be determined).

Once the changes above are available, a commit-reveal scheme can be implemented as follows. The coin toss example described [earlier](#motivation) will be used for illustration:

 - when a user submits a bidding transaction, the coin toss contract stores the block height where the bid was made and stores the bid amount on the application contract. This is a commitment by the user to use the SoR at the current block. Note that the current block's `SoR_A` isn't known to the transaction execution environment, and therefore the transaction has no way to inspect the random outcome and predict the coin toss result. The current block's `SoR_A` is only available once added to the history core-contract, which only happens at the end of the block's execution. 
 - the coin toss contract grants the user a limited window of time (i.e a block height range) to reveal the results and claim any winnings. Failing to do so, the user loses the bid amount in favour of the coin toss contract.  
 - within the valid window, a user can submit a second transaction to call the coin toss contract and resolve the bid. The coin toss contract looks up the committed block height of the user, then uses the block height to query the past-block's `SoR_A` on the history SoR core-contract.
 - the coin toss contract uses a PRG seeded by the queried `SoR_A` and diversified using a specific information to the use-case (a user ID or resource ID for instance). Diversification does not add any new entropy to the SoR's entropy, but avoids generating the same outcome for different use-cases. If a diversifier (or salt) isn't used, all users that committed a bid on the same block would either win or lose.
 - The PRG is used to generate the random result and resolve the bid. Note that the user can make the transaction abort after inspecting a losing result. However, the bid amount would be lost anyway when the allocated window expires.

  Notes: 
 - SoR is public data that is part of the block's payload in Flow. However, block history in Flow is truncated at each Spork and consensus nodes are not required to keep the full block history. Storing the history in the execution state is a safe way to track past-Spork SoRs since the execution state lives beyond Spork boundaries and is fork-aware. Correctness of the execution state is guaranteed by the verification and sealing processes. This is the reason the proposal suggests to keep the SoR history on a core-contract.
 - `N` should be large enough to store enough past history, and reasonably small to avoid a very large history size. We suggest a a value of `1200000` which covers about 2 weeks of history with a block rate of 1/second, and requires about 37Mb of minimum raw data storage (not including encoding overhead)
 - With the proposal above, there will be two ways to use randomness on-chain. One provided by Cadence's `unsafeRandom` (derived from the current block's SoR, let's call it `SoR_B`), and another provided by the SoR history core-contract (past blocks `SoR_A` via the new FVM function). It is important that the protocol uses independent SoRs (`SoR_A` and `SoR_B`), although both are derived from the unique Flow protocol distributed beacon. If `SoR_A` and `SoR_B` are equal, a user could use the Cadence function `unsafeRandom` in the commitment phase to predict the randoms that will be drawn in the future reveal transaction. The independence of SoRs is already enforced because `SoR_B` is [diversified per transaction](https://github.com/onflow/flow-go/blob/f2bc373/fvm/environment/random_generator.go#L94-L100), but extra safety diversification should be added when extracting the [execution SoRs](https://github.com/onflow/flow-go/blob/f2bc373a52912c7a936bee6e78e08246fab32add/state/protocol/prg/customizers.go#L23)(`SoR_A` and `SoR_B`).


### Drawbacks

- commit-reveal protocols are implemented over two rounds, which represents a friction for the application user and adds complexity for contract developers.
- once the bets are committing, the amount remains in escrow on the application contract. This can open back-doors for a malicious application to run away with the bid amount by updating the contract. A frozen contract (all the account keys get revoked) is an option to get users to trust the application.

### Alternatives Considered

- a one-round solution would be to implement a commit-reveal through one user action only: a user sends a commit transaction calling the application contract. The commit triggers the application contract to defer a transaction to run in the future (same block or subsequent one). The deferred transaction is be non-revertible by the user. This alternative requires Cadence to support deferred actions which is not available at the moment.

- another way to use randomness is to implement a commit-reveal scheme over two rounds, but with hiding the random result from the user transaction environment: When the user submits a bidding transaction, the application contract executes the randomized algorithm (coin toss for instance) and returns the result encapsulated into a Cadence object with private attributes. The user transaction should have no way to inspect the the private attributes in order to potentially abort the transaction. The user still needs to submit a second transaction to resolve the results of the Cadence object. Although this method avoids having the bid amount in escrow on the application contract, it makes strong assumptions about a Cadence object. Any information leakage of the private attributes (gas consumption, encoding size..) into the user commit transaction may result in revealing the hidden result. There are no guarantees that the transaction execution environment will not be able to differentiate private attributes in the future, even though the method may be safe today. Another advantage of this method is that it works well with the current protocol infrastructure and does not require extra tools.

### Performance Implications

- There is no timing and gas impact other then the PRG is being executed on-chain.
- The core-contract will have to store the SoR history for a limited window. For `N` equal to 1200000, the storage size is at least 37Mb (not counting the encoding overhead).

### Dependencies

None

### Engineering Impact

The points 1, 2 and 3 in [the design proposal](#design-proposal) need to be built as part of this proposal.

### Tutorials and Examples

Here is an example of a coin toss contract with one function to commit a bid, and another function to resolve the bid:

```
import SoRHistory from 0xFLOWSORHISTORY

cointossCommit(bet: @FlowToken.Vault) : @Receipt {
		let receipt <- create Receipt(
					betAmount: bet.balance,
					commitBlock: getCurrentBlock().height
		)
		self.reserve.deposit(from: <-bet)
    return <- receipt
}

const let expiryWindowLength = 1000000

cointossReveal(receipt: @Receipt) : @FlowToken.Vault {
		let currentBlock = getCurrentBlock().height
		if receipt.commitBlock >= currentBlock {
			panic("cannot reveal yet")
		}
        if receipt.commitBlock + expiryWindowLength > currentBlock {
            return <-FlowToken.createEmptyVault()
        }
		
		let coin = randomCoin(atBlock: receipt.commitBlock, salt: receipt.id)
		destroy receipt

		if coin == 1 {
			return <-FlowToken.createEmptyVault()
		}
		
		return <-self.reserve.withdraw(amount: receipt.betAmount * 2)
}

fun randomCoin(atBlock: UInt64, salt: [UInt8]) : UInt8 {
    let sor = SoRHistory.getSoR(atBlock)
    var prg = createPRG(sor, salt)
    let rand = prg.Uint64()
    return rand & 1
}
```
